from starkware.cairo.common.builtin_poseidon.poseidon import poseidon_hash, poseidon_hash_many
from starkware.cairo.common.cairo_builtins import PoseidonBuiltin
from starkware.cairo.common.math import assert_nn_le
from starkware.cairo.common.uint256 import Uint256
from starkware.starknet.core.os.data_availability.bls_field import (
    BigInt3,
    bigint3_to_uint256,
    felt_to_bigint3,
    horner_eval,
    reduced_mul,
)

const BLOB_LENGTH = 4096;

// Represents an integer in the range [0, 2^384).
struct Uint384 {
    // The low 192 bits of the value.
    low: felt,
    // The high 192 bits of the value.
    high: felt,
}

// Data required for KZG commitment on data-availability.
struct OsKzgCommitmentInfo {
    // KZG commitment on the data.
    kzg_commitment: Uint384,
    // Generated by hashing the Stark-friendly commitment with the KZG commitment.
    z: felt,
    // The value of the data polynomial at `z`.
    y: Uint256,
}

// Computes information needed for publishing data on L1 using KZG commitment.
//
// Specifically, let `p` be the data polynomial. The OS samples `p` at a point `z`,
// where `z` is generated using Fiat-Shamir heuristic.
//
// The OS uses a Stark-friendly commitment scheme, while the L1 side uses KZG.
// This requires combining them both in the generation of `z`; i.e.,
// the OS guesses (and outputs):
//   * kzg_commitment = KZG(data),
// computes:
//   * z = Poseidon(Poseidon(data), Poseidon(kzg_commitment.low, kzg_commitment.high)),
// and samples the polynomial:
//   * y = p(z).
//
// The L1 side will need to verify that `kzg_commitment` is correct
// and that `p(z) = y` (using a KZG proof).
func compute_os_kzg_commitment_info{range_check_ptr, poseidon_ptr: PoseidonBuiltin*}(
    state_updates_start: felt*, state_updates_end: felt*
) -> OsKzgCommitmentInfo* {
    alloc_locals;
    let da_size = state_updates_end - state_updates_start;
    assert_nn_le(da_size, BLOB_LENGTH);
    local kzg_commitment: Uint384;
    %{
        execution_helper.store_da_segment(
            da_segment=memory.get_range_as_ints(addr=ids.state_updates_start, size=ids.da_size)
        )
        segments.write_arg(
            ids.kzg_commitment.address_,
            execution_helper.polynomial_coefficients_to_kzg_commitment_callback(
                execution_helper.da_segment
            )
        )
    %}
    let (da_hash) = poseidon_hash_many(n=da_size, elements=state_updates_start);
    let (kzg_commitment_hash) = poseidon_hash(kzg_commitment.low, kzg_commitment.high);
    let (z) = poseidon_hash(da_hash, kzg_commitment_hash);

    // Evaluate y = p(z).
    let z_bigint = felt_to_bigint3(z);
    let unreduced_y = horner_eval(
        n_coefficients=da_size, coefficients=state_updates_start, point=z_bigint
    );
    // Call reduced_mul with 1 to get a reduced form of the value that satisfies the
    // assumptions of `bigint3_to_uint256`.
    let y_bigint = reduced_mul(unreduced_y, BigInt3(1, 0, 0));
    let y = bigint3_to_uint256(y_bigint);

    tempvar os_kzg_commitment_info = new OsKzgCommitmentInfo(
        kzg_commitment=kzg_commitment, z=z, y=y
    );
    return os_kzg_commitment_info;
}
